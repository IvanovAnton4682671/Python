
# Решение систем ДУ с использованием разностных схем
# Построить явную и неявную разностную схему решения уравнения, определить её устойчивость
# du/dt = d^2u/dx^2, 0 < x < pi/2, 0 < t <= T
# u(x, 0) = sin(x), 0 <= x <= pi/2
# u(0, t) = 0, u(pi/2, t) = e^(-t), 0 <= t <= T
# T выбрать самостоятельно
# Точное решение для проверки: u(x, t) = e^(-t)*sin(x)

# У нас имеется уравнение теплопроводности
# Процесс создания разностной схемы для такого уравнения включает в себя дискретизацию
# временной и пространственной областей и аппроксимацию дифференциальных операторов разностными отношениями
# В нашем случае имеется одномерное уравнение теплопроводности:
# du/dt = d^2u/dx^2 для 0 < x < pi/2 и 0 < t <= T
# С начальным условием:
# u(x, 0) = sin(x) для 0 <= x <= pi/2
# и граничными условиями:
# u(0, t) = 0 и u(pi/2, t) = e^(-t) для 0 <= t <= T

# Пусть T = 1

# 1. Дискретизация областей
# Разобьём интервал [0, pi/2] на N равных частей с шагом h: x_n = n * h, где n = 0, 1, ..., N и h = pi/(2 * N)
# Разобьём промежуток [0, T] на М частей с шагом tau: t_m = m * tau, где m = 0, 1, ..., M и tau = T / M
# Теперь u_n^m приблизительно соответствует u(x_n, t_m)

# 2. Разностные аппроксимации
# Для того, чтобы построить явную схему, будем использовать разностную аппроксимацию:
# Временная производная: (du/dt)_n^m = (u_n^(m+1) - u_n^m) / tau
# Пространственная производная: (d^2u/dx^2)_n^m = (u_(n+1)^m - 2u_n^m + u_(n-1)^m) / h^2
# Получаем явную схему:
# u_n^(m+1) = u_n^m + lambda*(u_(n+1)^m - 2u_n^m + u_(n-1)^m),
# гдя lambda = tau / h^2
# И неявную схему:
# u_n^(m+1) - lambda*(u_(n+1)^(m+1) - 2u_n^(m+1) + u_(n-1)^(m+1)) = u_n^m
# Это приводит к 3-диагональной системе уравнений, которую можно решить, например, методом прогонки

# 3. Условия устойчивости
# Явная схема устойчива, если соблюдается условие Куранта-Фридриха-Леви:
# lambda <= 1/2
# Неявная же схема безусловно устойчива и не требует выполнения условия КФЛ

# 4. Реализация граничных условий
# Нужно учитывать, что:
# u_0^m = 0 (первое граничное условие)
# u_N^m = e^(-t_m) (второе граничное условие)

# 5. Решение
# Теперь нужно реализовать явный и неявный метод решения данной системы, найти приближённое решение,
# сравнить его с точным решением и определить правильность и точность численного метода

import math as mt
import numpy as np
import matplotlib.pyplot as plt

# входные данные
T = 1
N = 10
M = 1000
h = mt.pi / (2 * N)
tau = T / M
lambda_ = tau / h**2

# -------------------- ЯВНЫЙ МЕТОД --------------------

# проверка устойчивости для явной схемы
if lambda_ > 0.5:
    print("Схема неустойчива, нужно уменьшить tau или увеличить h!")
else:
    print("Схема устойчива!")

# создание массивов
x = np.linspace(0, mt.pi/2, N+1)
t = np.linspace(0, T, M+1)
u = np.zeros((N+1, M+1))  # создание матрицы размерности N+1xM+1, которая заполнена 0.0

# установка начальных условий
u[:, 0] = np.sin(x)  # берутся все строки первого столбца и заполняются значениями sin(x)
u[0, :] = 0  # берутся все столбы первой строки и заполняются значениями 0
u[N, :] = np.exp(-t)

# итерационный процесс для явной схемы
# всё по методичке
for m in range(0, M):
    for n in range(1, N):
        u[n, m+1] = u[n, m] + lambda_ * (u[n-1, m] - 2 * u[n, m] + u[n+1, m])

# визуализация результатов
plt.figure(figsize=(8, 8))
# численное решение (явное)
plt.subplot(2, 2, 1)
plt.imshow(u, extent=[0, T, 0, mt.pi/2], origin="lower", aspect="auto")
plt.colorbar()
plt.title("Явная разностная схема")
plt.xlabel("Время")
plt.ylabel("X")

# -------------------- НЕЯВНЫЙ МЕТОД --------------------

# отдельные массивы для неявной схемы
u_implicit = np.zeros((N+1, M+1))
u_implicit[:, 0] = np.sin(x)
u_implicit[0, :] = 0
u_implicit[N, :] = np.exp(-t)

# метод прогонки (алгоритм Томаса)
# используется для решения систем вида:
# b_0*x_0 + c_0*x_1       = d_0,
# a_1*x_0 + b_1*x_1 + c_1*x_2 = d_1,
#           a_2*x_1 + b_2*x_2 + c_2*x_3 = d_2,
# ............................
#                    a_{n-1}*x_{n-2} + b_{n-1}*x_{n-1} = d_{n-1}
# Метод состоит из двух шагов: прямой прогонки и обратной прогонки.
# В прямой прогонке преобразуем исходную систему к эквивалентной системе с верхней треугольной матрицей,
# где b_i' и d_i' - новые преобразованные коэффициенты:
# После прямой прогонки мы переходим к обратной прогонке.
# На этом шаге система уже имеет верхнюю треугольную матрицу, и мы можем найти неизвестные,
# начиная с последнего и двигаясь в обратном порядке
def tdma_solver(a, b, c, d):
    nf = len(d)
    # map(function, iterable) - применяет функцию к всем объектам второго параметра
    ac, bc, cc, dc = map(np.array, (a, b, c, d))
    for it in range(1, nf):
        mc = ac[it-1]/bc[it-1]
        bc[it] = bc[it] - mc * cc[it-1]
        dc[it] = dc[it] - mc * dc[it-1]
    xc = bc
    xc[-1] = dc[-1]/bc[-1]
    for il in range(nf-2, -1, -1):
        xc[il] = (dc[il] - cc[il] * xc[il+1])/bc[il]
    return xc

# неявная схема
a_implicit = -lambda_ * np.ones(N-1)  # нижняя диагональ
b_implicit = (1 + 2 * lambda_) * np.ones(N-1)  # главная диагональ
c_implicit = -lambda_ * np.ones(N-1)  # верхняя диагональ

for m in range(0, M):
    d = u_implicit[1:-1, m].copy()  # d теперь массив N-1 элементов
    d[0] += lambda_ * u_implicit[0, m+1]  # добавляем к первому элементу d граничное состояние слева
    d[-1] += lambda_ * np.exp(-t[m+1])  # добавляем к последнему элементу d граничное состояние справа
    u_implicit[1:-1, m + 1] = tdma_solver(a_implicit, b_implicit, c_implicit, d)  # решаем систему для внутренних узлов

# численное решение (неявное)
plt.subplot(2, 2, 2)
plt.imshow(u_implicit, extent=[0, T, 0, mt.pi/2], origin="lower", aspect="auto")
plt.colorbar()
plt.title("Неявная разностная схема")
plt.xlabel("Время")
plt.ylabel("X")

# -------------------- ТОЧНОЕ РЕШЕНИЕ --------------------

# массив для точного решения
u_exact = np.zeros((N+1, M+1))

# заполнение массива точного решения значениями из аналитического выражения
for i in range(N+1):
    for j in range(M+1):
        u_exact[i, j] = np.exp(-t[j]) * np.sin(x[i])

plt.subplot(2, 2, 3)
plt.imshow(u_exact, extent=[0, T, 0, mt.pi/2], origin='lower', aspect='auto')
plt.colorbar()
plt.title("Точное решение")
plt.xlabel("Время")
plt.ylabel("X")
plt.show()

# -------------------- ОШИБКИ --------------------
errors_yav = abs(u_exact - u)
print("Погрешности решения явной схемой:")
print(errors_yav)
errors_neyav = abs(u_exact - u_implicit)
print()
print("Погрешности решения неявной схемой:")
print(errors_neyav)

